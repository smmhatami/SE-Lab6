# گزارش آزمایش پنجم درس مهندسی نرم افزار

## اعضای گروه

+ سید محمدمهدی حاتمی 98109561
+ پیمان حاجی محمد 98170776

## شرح آزمایش

در ابتدای امر همچون آزمایش های قبلی محیط گیت را راه اندازی کرده و قوانین لازم روی برنچ اصلی آن را اعمال می کنی. 
سپس در گام اول پروژه ی MiniJava را به پروژه ی خود اضافه می کنیم. به منظور اطمینان از تغییر نکردن عملکرد کد، کامپایلر را اجرا کرده و خروجی آن را برای مقایسه های بعدی ذخیره می کنیم. 

![Screenshot from 2023-12-11 09-03-18](https://github.com/smmhatami/SE-Lab6/assets/62210297/e679187f-07ef-46bc-b393-7d6e4e6e35ad)

حال پروژه ی خود را به سایت getcodeflow وصل می کنیم تا ایردات تشخیص داده شده توسط آن را ببینیم. 

![Screenshot from 2023-12-11 09-04-32](https://github.com/smmhatami/SE-Lab6/assets/62210297/28bc5b6e-39ba-4dc9-92f3-a2f182900882)

در ادامه به ترتیب بازآرایی های انجام شده در کد را توضیح می دهیم. 

### بازآرایی ۱ : الگوی Facade 
در گام اول مشاهده می کنیم که پکیج های parser و scanner همبستگی زیادی با هم دارند. به منظور کاهش وابستگی parser به scanner و جزئیات داخلی آن، یک کلاس Facade تحت عنوان ScannerFacade تعریف می کنیم و در داخل parser از آن استفاده می کنیم. همچنین برای جدا کردن parser از کلاس Token، یک پروکسی برای Token به نام MyToken تعریف میکنیم. 

### بازآرایی ۲ : الگوی Facade 
در گام دوم مشابه بازآرایی قبل، با استفاده از الگوی طراحی Facade تلاش می کنیم تا پکیج parser را از جزئیات داخلی پکیج codeGenerator جدا کنیم. 

### بازآرایی ۳ و ۴ :‌ استفاده از Polymorphism به جای شرط
در گام بعد به سراغ کلاس Action می رویم و مشاهده می کنیم که سه state مختلف دارد. هر کدام از این state ها علاوه بر این که toString متفاوتی دارند، در تابع parser منجر به استراتژی متفاوتی برای پارس کردن می شوند. در نتیجه با تعریف زیرکلاس هایی برای Action، ابتدا متد ToString را به صورت Polymorphism پیاده سازی و فراخوانی می کنیم و سپس استراتژی های مختلف را برای Parser در متد performAction پیاده سازی می کنیم. 

### بازآرایی ۵ :‌ اجرای Separate Query From Modifier
در کلاس Method در فایل SymbolTable مشاهده می کنیم که تابع getNextParameter هم پارامتر را یکی جلو برده و هم پارامتر فعلی را باز میگرداند. به منظور جدا کردن این دو عملکرد از یکدیگر به جای این تابع دو تابع جداگانه تعریف می کنیم و موارد استفاده از آن را نیز با این بازتعریف جدید متناسب می کنیم. 

### بازآرایی های کوچک : با استفاده از getcodeflow.com
پس از پیاده سازی بازآرایی های اصلی گفته شده در دستور آزمایش، با کمک گرفتن از سایت getcodeflow.com بازآرایی های کوچکی را برای بهتر شدن کد انجام دادیم که موضوعات آن ها از روی نام کامیت ها مشخص است و به علت متعدد و کوچک بودن آن ها را در اینجا ذکر نمی کنیم. 

## پرسش ها 
1. 
* کد تمیز به کدی گفته می شود که فهم آن برای اعضای مختلف یک تیم آسان بوده و زمان بر نباشد. برای رسیدن به این هدف مجموعه ی قواعدی تعریف شده است که اگر تمام اعضای تیم های فنی آن ها را رعایت کنند، کد های افراد مختلف ساختار مشابهی پیدا کرده و فهم و توسعه ی تیمی آن ساده تر می شود.
* بدهی فنی عبارت از مجموعه ی نقصان هایی است که به مرور توسعه ی پروژه توسط تیم در آن به وجود می آید ولی به منظور بالا بردن سرعت توسعه، از برطرف کردن آن ها صرف نظر می شود. این نقصان ها عموما تاثیر جدی و مخرب بر عملکرد نهایی پروژه ندارند ولی در بلند مدت و در صورت تلنبار شدن، با ایجاد مشکلات متنوعی سرعت توسعه ی پروژه را کاهش می دهند. تمیز نبودن کد یا بهینه نبودن الگوریتم ها مثال هایی از بدهی های فنی هستند.
* بوی بد به نشانه هایی در کد اطلاق می شود که معمولا نشانه ای از ایرادات عمیق تر در پروژه هستند. آگاهی از این نشانه که به صورت تجربی به دست آمده اند به توسعه دهندگان کمک می کند که بسیاری از کاستی های کد را پیش از آن که به مشکلات جدی منجر شوند پیدا کرده و برطرف کنند.

2. 
* دسته ی اول، Bloaters :‌ این بوی بد وقتی استشمام می شود که بخشی از کد (مثلا یک کلاس یا یک تابع) بسیار بزرگ و حجیم شده است و کار کردن با آن به مرور زمان سخت تر و سخت تر می شود. در این مواقع باید تلاش کنیم که عملکرد های این بخش از کد را بین بخش های دیگر تقسیم کنیم. 


