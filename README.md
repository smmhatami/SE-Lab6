# گزارش آزمایش پنجم درس مهندسی نرم افزار

## اعضای گروه

+ سید محمدمهدی حاتمی 98109561
+ پیمان حاجی محمد 98170776

## شرح آزمایش

در ابتدای امر همچون آزمایش های قبلی محیط گیت را راه اندازی کرده و قوانین لازم روی برنچ اصلی آن را اعمال می کنی. 
سپس در گام اول پروژه ی MiniJava را به پروژه ی خود اضافه می کنیم. به منظور اطمینان از تغییر نکردن عملکرد کد، کامپایلر را اجرا کرده و خروجی آن را برای مقایسه های بعدی ذخیره می کنیم. 

![Screenshot from 2023-12-11 09-03-18](https://github.com/smmhatami/SE-Lab6/assets/62210297/e679187f-07ef-46bc-b393-7d6e4e6e35ad)

حال پروژه ی خود را به سایت getcodeflow وصل می کنیم تا ایردات تشخیص داده شده توسط آن را ببینیم. 

![Screenshot from 2023-12-11 09-04-32](https://github.com/smmhatami/SE-Lab6/assets/62210297/28bc5b6e-39ba-4dc9-92f3-a2f182900882)

در ادامه به ترتیب بازآرایی های انجام شده در کد را توضیح می دهیم. 

### بازآرایی ۱ : الگوی Facade 
در گام اول مشاهده می کنیم که پکیج های parser و scanner همبستگی زیادی با هم دارند. به منظور کاهش وابستگی parser به scanner و جزئیات داخلی آن، یک کلاس Facade تحت عنوان ScannerFacade تعریف می کنیم و در داخل parser از آن استفاده می کنیم. همچنین برای جدا کردن parser از کلاس Token، یک پروکسی برای Token به نام MyToken تعریف میکنیم. 

### بازآرایی ۲ : الگوی Facade 
در گام دوم مشابه بازآرایی قبل، با استفاده از الگوی طراحی Facade تلاش می کنیم تا پکیج parser را از جزئیات داخلی پکیج codeGenerator جدا کنیم. 

### بازآرایی ۳ و ۴ :‌ استفاده از Polymorphism به جای شرط
در گام بعد به سراغ کلاس Action می رویم و مشاهده می کنیم که سه state مختلف دارد. هر کدام از این state ها علاوه بر این که toString متفاوتی دارند، در تابع parser منجر به استراتژی متفاوتی برای پارس کردن می شوند. در نتیجه با تعریف زیرکلاس هایی برای Action، ابتدا متد ToString را به صورت Polymorphism پیاده سازی و فراخوانی می کنیم و سپس استراتژی های مختلف را برای Parser در متد performAction پیاده سازی می کنیم. 

### بازآرایی ۵ :‌ اجرای Separate Query From Modifier
در کلاس Method در فایل SymbolTable مشاهده می کنیم که تابع getNextParameter هم پارامتر را یکی جلو برده و هم پارامتر فعلی را باز میگرداند. به منظور جدا کردن این دو عملکرد از یکدیگر به جای این تابع دو تابع جداگانه تعریف می کنیم و موارد استفاده از آن را نیز با این بازتعریف جدید متناسب می کنیم. 









